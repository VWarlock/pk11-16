.TITLE	SPRITE_OUT	; ┌─────────────────────────────────────────────┐
.ENABL	MCL		; │ Вывод спрайтов по сетевому таймеру игрульки │
.INCLU	/SY:P16MAC/	; │		     DEAMONDS . 		│
.INCLU	/SY:WDC/	; └─────────────────────────────────────────────┘
;────────────────────────────────────────────────────────────────────────────
.GLOBL	TASGAME,SAVREG,DIAPAL
;────────────────────────────────────────────────────────────────────────────
;				КОНСТАНТЫ .
;────────────────────────────────────────────────────────────────────────────
MYSTACK		=	600	; Вершина своего стека .
MYPRIORITET	=	6000	; Свой приоритет .
MYREGISTER	=	176602	; Регистр процесса .
REGIDENT	=	2	; Идентификатор прерывания от регистра .
WINDOW		=	140010	; Смещение до начала отображения .
SPRREGISTER	==	MYREGI	; Регистр процесса .
OFFINT		==	0	; Выключить прерывание .
ONINT		==	2	; Включить прерывание .
PUTSPRITE	==	4	; Вывести спрайт .
;────────────────────────────────────────────────────────────────────────────
;				ИНИЦИАЛИЗАЦИЯ .
;────────────────────────────────────────────────────────────────────────────
SINIT::
	NEWROMP	#SPR.PROCESS	; Запустить спрайтовый процесс .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;				СПРАЙТОВЫЙ ПРОЦЕСС .
;────────────────────────────────────────────────────────────────────────────
SPR.PROCESS::
	MOV	#MYSTACK,SP	; Своя область стека .
	UNPREG	#MYREGISTER	; Освободить свой регистр .
	PROREG	#BLKREGISTER	; Захватить свой регистр .
	SETPRI	#MYPRIO		; Выставить свой приоритет .
1$:	CLR	R0		; При вызове по времени .
	MOV	#1,R3		; Длительность задержки .
	WAITINT	#M.TIO		; Дождаться его .
	TST	R0		; Вызов по времени ?
	BEQ	3$		; Да .
	CALL	REGCALL		; Обработать регистр .
	BR	1$		; Повторить .
3$:	CALL	TIMCALL		; Подпрограмы по регистру или таймеру .
	BR	1$		; Повторить .
;────────────────────────────────────────────────────────────────────────────
;			ОБРАБОТКА ОБРАЩЕНИЙ ПО РЕГИСТРУ .
;────────────────────────────────────────────────────────────────────────────
REGCALL:
	MOV	@#MYREGISTER,R0	; 0 - ;
				; 2 - ;
				; 4 - поместить спрайт в буфер .
	JMP	@1$(R0)		; Обработать запрос .
				; Адреса подпрограмм обработки .
1$:	.WORD	RET,RET,OUTSPRITE
;────────────────────────────────────────────────────────────────────────────
;			ЗАНЕСЕНИЕ СПРАЙТА В ОЧЕРЕДЬ .
;────────────────────────────────────────────────────────────────────────────
OUTSPRITE:
	MOV	SPRSAV,@BEGPOI	; Занести адрес описания спрайта .
	ADD	#2,BEGPOINTER	; Сместиться по буферу .
	CMP	BEGPOI,#BEGPOI	; Конец буфера ?
	BLO	1$		; Нет .
	MOV	#SPRBUFER,BEGPOI; Перейти на начало .
1$:	INC	SPRCOUNTER	; Увеличить счетчик .
RET::	RETURN
;────────────────────────────────────────────────────────────────────────────
;			ОБРАБОТКА ОБРАЩЕНИЙ ПО ТАЙМЕРУ .
;────────────────────────────────────────────────────────────────────────────
TIMCALL:
	MOV	ENDPOINTER,R5	; Конец буфера .
1$:	DEC	SPRCOUNTER	; Есть спрайты на вывод ?
	BMI	2$		; Нет .
	MOV	(R5)+,R0	; Адрес текущего описания спрайта .
	MOV	R5,-(SP)	; Сохранить РОН .
	CALL	@(R0)+		; Исполнить вывод на экран .
	MOV	(SP)+,R5	; Восстановить РОН .
	CMP	R5,#BEGPOINTER	; Переходить на начало ?
	BLO	1$		; Нет .
	MOV	#SPRBUFER,R5	; Начало .
	BR	1$		; Повторить .
2$:	MOV	BEGPOI,ENDPOI	; Конец = начало .
	CLR	SPRCOUNTER	; Всё вывели .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			ВЫВОД СПРАЙТА С ТОЧНОСТЬЮ ДО 8 СЛОВ .
;────────────────────────────────────────────────────────────────────────────
$WORD::
	MOV	(R0)+,R1	; X спрайта .
	MOV	(R0)+,R2	; Y спрайта
	MOV	(R0)+,R3	; Адрес спрайта .
	ASH	#4,R1		; Адрес по массиву => адрес слова .
	ADD	#WINDOW,R1	; + смещение до отображения .
	ASH	#6,R2		; Адрес по массиву => адрес по ТАС .
	ADD	#TASGAME,R2	; Начало ТАС .
	MOV	#UR6,R4		; Регистр отображения .
	MOV	#20,R5		; Высота спрайта .
1$:	MOV	2(R2),R0	; ┐
	BIC	#17,R0		; Отобразить .
	MOV	R0,(R4)		; ┘
	MOV	R1,R0		; Адрес в памяти .
	ADD	(R2)+,R0	; + смещение до строки .
	MOV	(R3)+,(R0)+	; ┐
	MOV	(R3)+,(R0)+	; │
	MOV	(R3)+,(R0)+	; │
	MOV	(R3)+,(R0)+	; Вывод строки .
	MOV	(R3)+,(R0)+	; │
	MOV	(R3)+,(R0)+	; │
	MOV	(R3)+,(R0)+	; │
	MOV	(R3)+,(R0)	; ┘
	TST	(R2)+		; Сместиться по ТАС .
	SOB	R5,1$		; Повторить для всего спрайта .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			СБРОС МАСКИ С ТОЧНОСТЬЮ ДО 8 СЛОВ .
;────────────────────────────────────────────────────────────────────────────
$WCLEAR::
	MOV	(R0)+,R1	; X спрайта .
	MOV	(R0)+,R2	; Y спрайта
	MOV	(R0)+,R3	; Адрес маски .
	ASH	#4,R1		; Адрес по массиву => адрес слова .
	ADD	#WINDOW,R1	; + смещение до отображения .
	ASH	#6,R2		; Адрес по массиву => адрес по ТАС .
	ADD	#TASGAME,R2	; Начало ТАС .
	MOV	#UR6,R4		; Регистр отображения .
	MOV	#20,R5		; Высота маски .
1$:	MOV	2(R2),-(SP)	; Модель для отображения .
	BIC	#17,(SP)	; Выключить прозрачный режим .
	MOV	(SP)+,(R4)	; Отобразить .
	MOV	R1,R0		; Адрес в памяти .
	ADD	(R2)+,R0	; + смещение до строки .
	BIC	(R3)+,(R0)+	; ┐
	BIC	(R3)+,(R0)+	; │
	BIC	(R3)+,(R0)+	; │
	BIC	(R3)+,(R0)+	; Вывод строки .
	BIC	(R3)+,(R0)+	; │
	BIC	(R3)+,(R0)+	; │
	BIC	(R3)+,(R0)+	; │
	BIC	(R3)+,(R0)	; ┘
	TST	(R2)+		; Сместиться по ТАС .
	SOB	R5,1$		; Повторить для всей маски .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			ВЫВОД СПРАЙТА С ТОЧНОСТЬЮ ДО ТОЧКИ .
;────────────────────────────────────────────────────────────────────────────
$POINT::
	MOV	(R0)+,R1	; X .
	MOV	(R0)+,R2	; Y .
	MOV	(R0)+,R3	; Адрес спрайта .
	MOV	(PC)+,@(PC)+	; Хотелось бы чтобы спрайт
	BR	.+4		;   был размещен на экране
	.WORD	4$		;          точно по байтам .
	ASR	R1		; Преобразовать точки в байты .
	BCC	1$		; Если точно по байтам .
	MOV	(PC)+,@(PC)+	; Сдвигать каждый раз
	ASH	#4$,R0		; при выводе на экран .
1$:	ADD	#WINDOW,R1	; + смещение до отображения .
	ASL	R2		; Номер строки => адрес по ТАС .
	ASL	R2		; ┘
	ADD	#TASGAME,R2	; + адрес ТАС .
	MOV	#20,R5		; Высота спрайта .
	MOV	R1,-(SP)	; Сохранить адрес спрайта .
2$:	MOV	2(R2),@#UR6	; Отобразить .
	MOV	(SP),R1		; Адрес спрайта .
	ADD	(R2)+,R1	; + смещение по отображению .
	MOV	#10,R4		; Ширина спрайта в байтах .
3$:	MOVB	(R3)+,R0	; Очередной байт спрайта .
	BIC	#177400,R0	; Сбросить лишнее .
4$:	ASH	#4,R0		; Сдвинуть , если надо .
	MOVB	R0,(R1)+	; Записать мл. часть .
	SWAB	R0		; ┐
	MOVB	R0,(R1)		; Записать ст. часть .
	SOB	R4,3$		; Повторить для строки .
	TST	(R2)+		; Перейти по ТАС .
	SOB	R5,2$		; Повторить для спрайта .
	TST	(SP)+		; Восстановить стек .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			СБРОС МАСКИ С ТОЧНОСТЬЮ ДО ТОЧКИ .
;────────────────────────────────────────────────────────────────────────────
$PCLEAR::
	MOV	(R0)+,R1	; X .
	MOV	(R0)+,R2	; Y .
	MOV	(R0)+,R3	; Адрес маски .
	MOV	(PC)+,@(PC)+	; Хотелось бы чтобы маска
	BR	.+4		; была размещена на экране
	.WORD	4$		;         точно по байтам .
	ASR	R1		; Преобразовать точки в байты .
	BCC	1$		; Если точно по байтам .
	MOV	(PC)+,@(PC)+	; Сдвигать каждый раз
	ASH	#4$,R0		; при выводе на экран .
1$:	ADD	#WINDOW,R1	; + смещение до отображения .
	ASL	R2		; Номер строки => адрес по ТАС .
	ASL	R2		; ┘
	ADD	#TASGAME,R2	; + адрес ТАС .
	MOV	#20,R5		; Высота маски .
	MOV	R1,-(SP)	; Сохранить адрес маски .
2$:	MOV	2(R2),-(SP)	; Модель для отображения .
	BIC	#17,(SP)	; Сбросить прозрачный режим .
	MOV	(SP)+,@#UR6	; Отобразить .
	MOV	(SP),R1		; Адрес маски .
	ADD	(R2)+,R1	; + смещение по отображению .
	MOV	#10,R4		; Ширина спрайта в байтах .
3$:	MOVB	(R3)+,R0	; Очередной байт спрайта .
	BIC	#177400,R0	; Сбросить лишнее .
4$:	ASH	#4,R0		; Сдвинуть , если надо .
	BICB	R0,(R1)+	; Очистить мл. часть .
	SWAB	R0		; ┐
	BICB	R0,(R1)		; Очистить ст. часть .
	SOB	R4,3$		; Повторить для строки .
	TST	(R2)+		; Перейти по ТАС .
	SOB	R5,2$		; Повторить для маски .
	TST	(SP)+		; Восстановить стек .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;		ВЫВОД ПРОИЗВОЛЬНОГО СПРАЙТА С ТОЧНОСТЬЮ ДО СЛОВА .
;────────────────────────────────────────────────────────────────────────────
BIGSPR::
				; R0 - Гор. смещение в байтах .
				; R1 - Адрес спрайта .
				; R5 - Адрес ТАС .

	CALL	SAVREG		; Сохранить регистры .
	MOV	@#UR6,-(SP)	; Сохранить регистр отображения .
	ADD	#140000,R0	; + смещение до отображения .
	MOV	(R1)+,R4	; Ширина .
	MOV	(R1)+,R3	; Высота .
	MOV	R4,-(SP)	; Сохранить ширину .
1$:	MOV	(SP),R4		; Взять ширину .
	MOV	2(R5),R2	; ┐
	BIC	#17,R2		; Отобразить строку .
	MOV	R2,@#UR6	; ┘
	MOV	(R5)+,R2	; Адрес начала строки .
	ADD	R0,R2		; + смещение .
2$:	MOV	(R1)+,(R2)+	; Записать слово .
	SOB	R4,2$		; Повторить для ширины .
	TST	(R5)+		; Сместиться по ТАС .
	SOB	R3,1$		; Повторить для ширины .
	TST	(SP)+		; Восстановить стек .
	MOV	(SP)+,@#UR6	; Восстановить регистр отображения .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;		ВЫВОД ЧИСЕЛ В ИНДИКАТОРЫ С ТОЧНОСТЬЮ ДО БАЙТА .
;────────────────────────────────────────────────────────────────────────────
OUTCIF::
				; Адрес блока запроса в R0 .
				; Блок запроса :
				; 1 слово - адрес переменной ;
				; 2 слово - длина выходного числа ;
				; 3 слово - гор. смещение в байтах ;
				; 4 слово - адрес ТАС .

	CALL	SAVREG		; Сохранить регистры .
	MOV	@#UR6,-(SP)	; Сохранить отображение .
	MOV	@(R0)+,R3	; Число .
	MOV	(R0)+,R1	; Длина строки .
	CLR	-(SP)		; Признак конца строки .
1$:	CLR	R2		; ┐
	DIV	#10.,R2		; Разделить число на ОСС .
	ASH	#7,R3		; Превратить в смещение по спрайту .
	ADD	#CIF+4,R3	; + адрес 0 .
	MOV	R3,-(SP)	; Запомнить цифру .
	MOV	R2,R3		; Подготовиться к след. проходу .
	SOB	R1,1$		; Если строка не кончилась .
	MOV	(R0)+,R4	; Смещение до начала строки .
	ADD	#140000,R4	; + смещение до отображения .
	MOV	(R0),R5		; Адрес ТАС .
	BR	5$		; Начать .
2$:	MOV	#20,R3		; Высота в строках .
3$:	MOV	2(R5),R1	; Адрес для отображения .
	BIC	#17,R1		; Непрозрачный режим .
	MOV	R1,@#UR6	; Отобразить .
	MOV	(R5)+,R1	; Адрес по отображению .
	ADD	R4,R1		; + смещение до отображения + гор. смещение .
	MOV	#10,R2		; Ширина в байтах .
4$:	MOVB	(R0)+,(R1)+	; Нарисовать строку .
	SOB	R2,4$		; ┘
	TST	(R5)+		; Сместиться по ТАС .
	SOB	R3,3$		; Повторить для всей цифры .
	ADD	#10,R4		; К след. цифре по горизонтали .
	SUB	#100,R5		; Вернуться по ТАС .
5$:	MOV	(SP)+,R0	; Очередная цифра .
	BNE	2$		; Если цифры не кончились .
	MOV	(SP)+,@#UR6	; Восстановить отображение .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			РИСОВАНИЕ БОЛЬШИХ ЦИФР .
;────────────────────────────────────────────────────────────────────────────
BIGCIF::
	CALL	SAVREG		; Сохранить регистры .
	CALL	MAKEKVAD	; Сделать заставку .
	MOV	NUM.LAB,R1	; Уровень .
	CLR	R0		; ┐
	DIV	#10.,R0		; Разделить на две цифры .
	MOV	#TASGAM+<64.*4>,R5
	MOV	#76.,R4		; ┐
	CALL	1$		; Напечатать цифру #1 .
	MOV	R1,R0		; ┐
	MOV	#108.,R4	; Напечатать цифру #2 .
	CALL	1$		; ┘
	RETURN

1$:	CALL	SAVREG		; Сохранить регистры .
	ASL	R0		; ┐
	MOV	SPCIF(R0),R2	; Взять адрес спрайта .
	MOV	#7$,R3		; Таблица смещений .
	MOV	#15.,R0		; Длина цифры .
2$:	MOV	R0,-(SP)	; Сохранить счетчик .
	MOV	(R2)+,R1	; Адрес спрайта .
	BNE	3$		; Если не пустое место .
	CMP	(R3)+,(R3)+	; Сместиться по смещениям .
	BR	4$		; Новый цикл .
3$:	ADD	#KUBIKI-4,R1	; + смещение до блока спрайтов .
	MOV	R4,R0		; Гор. смещение до него .
	ADD	(R3)+,R0	; ┘
	MOV	R5,-(SP)	; Сохранить ТАС .
	MOV	(R1),-(SP)	; Сохранить место под заголовком спрайта .
	MOV	2(R1),-(SP)	; ┘
	MOV	#4,(R1)		; Записать заголовок .
	MOV	#16.,2(R1)	; ┘
	ADD	(R3)+,R5	; Сместиться по ТАС .
	CALL	BIGSPR		; Нарисовать спрайт .
	MOV	(SP)+,2(R1)	; Восстановить заголовок .
	MOV	(SP)+,(R1)	; ┘
	MOV	(SP)+,R5	; Восстановить ТАС .
4$:	MOV	(SP)+,R0	; Восстановить счетчик .
	SOB	R0,2$		; Повторить для всей цифры .
	RETURN
7$:				; Данные для печати цифры .
	0,000,8.,000,16.,000
	0,100,8.,100,16.,100
	0,200,8.,200,16.,200
	0,300,8.,300,16.,300
	0,400,8.,400,16.,400

;────────────────────────────────────────────────────────────────────────────
;				ВЫВОД ПНЯ С ТОПОРОМ .
;────────────────────────────────────────────────────────────────────────────
OUTPEN::
	CALL	SAVREG		; Сохранить регистры .
	CALL	MAKEKVAD	; Сделать заставку .
	MOV	#78.,R0		; ┐
	MOV	#PEN,R1		; Нарисовать пень с топором .
	MOV	#TASGAM+<78.*4>,R5;
	CALL	BIGSPR		; ┘
	RETURN
;────────────────────────────────────────────────────────────────────────────
;				РИСОВАНИЕ ЗАСТАВКИ .
;────────────────────────────────────────────────────────────────────────────
MAKEKVAD:
	MOV	@#UR6,-(SP)	; Сохранить отображение .
	MOV	#5$,R2		; ┐
	CALL	CREAREA		; Очистить экран .
	MOV	#6$,R5		; ┐
	CALL	OUTL		; Нарисовать рамку .
	MOV	(SP)+,@#UR6	; Восстановить отображение .
	RETURN

5$:				; Данные для очистки окна .
	TASGAM,8.,0,192.,208.,0,0
6$:				; Данные для рамки .
	TASGAM,60.,48.,88.,112.,UPLIN,^B1110111011101110,-1
;────────────────────────────────────────────────────────────────────────────
;			ПОДЖИГАНИЕ ПАЛИТРЫ .
;────────────────────────────────────────────────────────────────────────────
PALON::
	CALL	SAVREG		; Сохранить регистры .
1$:	MOV	#20,R5		; Длина палитры .
	MOV	#BUFRGB,R4	; Буфер с составляющими .
	MOV	#DIAPAL+4,R3	; Адрес выходной палитры .
2$:	MOV	#COLS,R2	; Буфер для цветов .
	MOV	#3,R1		; Кол-во цветов .
3$:	INC	(R4)		; Просветлить .
	CMP	R1,#1		; Это зелёный ?
	BNE	4$		; Нет .
	INC	(R4)		; Просветлить .
4$:	MOV	(R4)+,(R2)+	; Записать в буфер .
	BPL	5$		; Если больше чёрного .
	CLR	-2(R2)		; Чёрный .
5$:	SOB	R1,3$		; Повторить для всех цветов .
	CALL	PUTPAL		; Расчитать слово палитры .
	MOVB	R0,(R3)+	; ┐
	SWAB	R0		; Записать его .
	MOVB	R0,17(R3)	; ┘
	SOB	R5,2$		; Повторить для всей палитры .
	MOV	#3000.,R0	; Задержка .
	SOB	R0,.		; ┘
	PLMODx	#DIAPAL		; Модифицировать палитру .
	CMP	DIAPAL+4,BUFPAL	; Палитра = исходной ?
	BNE	1$		; Нет .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			ГАШЕНИЕ ПАЛИТРЫ .
;────────────────────────────────────────────────────────────────────────────
PALOFF::
	CALL	SAVREG		; Сохранить регистры .
	MOV	#DIAPAL+4,R4	; Адрес палитры .
	MOV	(R4),BUFPAL	; Запомнить слово палитры .
	MOV	#BUFRGB,R3	; Буфер под RGB .
	MOV	#20,R5		; Длина палитры в словах .
1$:	MOVB	(R4)+,2$	; Младший байт .
	MOVB	17(R4),2$+1	; Старший байт .
	MOV	(PC)+,R0	; Занести слово палитры в РОН .
2$:	.WORD	0		; ┘
	CALL	GETPAL		; Разделить на RGB .
	MOV	#COLS,R0	; Буфер с RGB .
	MOV	(R0)+,(R3)+	; ┐
	MOV	(R0)+,(R3)+	; Переписать в буфер гашения .
	MOV	(R0)+,(R3)+	; ┘
	SOB	R5,1$		; Повторить для всей палитры .
3$:	MOV	#20,R5		; Длина палитры .
	MOV	#BUFRGB,R4	; Буфер с RGB .
	MOV	#DIAPAL+4,R3	; Выходная палитра .
	CLR	8$		; Признак окончания .
4$:	MOV	#3,R2		; Кол-во цветов .
	MOV	#COLS,R1	; Буфер для цветов .
5$:	INC	8$		; Будес считать что не погашено .
	DEC	(R4)		; Уменьшить цвет .
	CMP	R2,#1		; Это зелёный ?
	BNE	6$		; Нет .
	DEC	(R4)		; Ещё загасить .
6$:	MOV	(R4)+,(R1)+	; Записать в выходную палитру .
	BPL	7$		; Если действительно не погашено .
	CLR	-2(R1)		; Цвет = 0 .
	DEC	8$		; Не угадал .
7$:	SOB	R2,5$		; Повторить для всех цветов .
	CALL	PUTPAL		; Собрать в слово палитры .
	MOVB	R0,(R3)+	; Записать мл. байт .
	SWAB	R0		; Записать ст. байт .
	MOVB	R0,17(R3)	; ┘
	SOB	R5,4$		; Повторить для всей палитры .
	MOV	#3000.,R0	; Задержка .
	SOB	R0,.		; ┘
	PLMODx	#DIAPAL		; Модифицировать палитру .
	TST	(PC)+		; Всё чёрное ?
8$:	.WORD	0		; ┘
	BNE	3$		; Нет .
	RETURN
;────────────────────────────────────────────────────────────────────────────
;			ПРЕОБРАЗОВАНИЕ ПАЛИТРЫ В RGB .
;────────────────────────────────────────────────────────────────────────────
;  7  6  5  4  3  2  1  0   7  6  5  4  3  2  1  0
;┌────────┬────────┬─────┐ ┌────────┬─────┬────────┐
;│G5 G4 G3│R4 R3 R2│B4 B3│ │G2 G1 G0│R1 R0│B2 B1 B0│
;└────────┴────────┴─────┘ └────────┴─────┴────────┘
GETPAL:
	CALL	SAVREG		; Сохранить регистры .
	SWAB	R0		; Подготовить .
	MOV	#COLS,R3	; Буфер для цветов .
	MOV	#2$,R4		; Буфер с данными .
	MOV	#3,R5		; Кол-во цветов .
1$:	MOV	R0,R1		; Размножить слово палитры .
	MOV	R0,R2		; ┘
	ASH	(R4)+,R1	; ┐
	BIC	(R4)+,R1	; │
	ASH	(R4)+,R2	; Расчитать цвет .
	BIC	(R4)+,R2	; │
	BIS	R2,R1		; ┘
	MOV	R1,(R3)+	; Занести цвет .
	SOB	R5,1$		; Повторить для всех .
	RETURN
				; Данные .
2$:	.WORD	0,^C7,-5,^C30
	.WORD	-3,^C3,-8.,^C34
	.WORD	-5,^C7,-10.,^C70
;────────────────────────────────────────────────────────────────────────────
;			ПРЕОБРАЗОВАНИЕ RGB В ПАЛИТРУ .
;────────────────────────────────────────────────────────────────────────────
PUTPAL:
	CALL	SAVREG		; Сохранить регистры .
	CLR	R0		; Буфер под слово палитры .
	MOV	#3,R3		; Кол-во планов .
	MOV	#2$,R4		; Буфер с данными .
	MOV	#COLS,R5	; Буфер с цветами .
1$:	MOV	(R5)+,R1	; Взять цвет .
	MOV	R1,R2		; ┘
	ASH	(R4)+,R1	; ┐
	BIC	(R4)+,R1	; Записать первую половину .
	BIS	R1,R0		; ┘
	ASH	(R4)+,R2	; ┐
	BIC	(R4)+,R2	; Записать вторую половину .
	BIS	R2,R0		; ┘
	SOB	R3,1$		; Повторить для всех цветов .
	SWAB	R0		; Слово палитры .
	RETURN
2$:				; Данные .
.WORD	0,^C7,5,^C1400
.WORD	3,^C30,8.,^C16000
.WORD	5,^C340,10.,^C160000
;────────────────────────────────────────────────────────────────────────────
;			ПЕРЕМЕННЫЕ И КОНСТАНТЫ .
;────────────────────────────────────────────────────────────────────────────
BLKREGISTER:		; Блок описания регистра .
	.WORD	MYREGISTER,0,0,2000,REGIDENT,-1
SPRBUFER:		; Буфер под спрайты .
	.BLKW	20.
BEGPOINTER:		; Указатель начала .
	.WORD	SPRBUFER
ENDPOINTER:		; Указатель конца .
	.WORD	SPRBUFER
SPRCOUNTER::		; Счетчик спрайтов на вывод .
	.WORD	0
SPRSAVER::		; Хранение адреса спрайта .
	.WORD	0
BUFPAL:			; Слово для сохранения гасимой палитры .
	.WORD	0
BUFRGB:			; Буфер погашеной палитры в RGB .
	.BLKW	32.*3
COLS:			; Буфер для RGB .
	.BLKW	3
SPCIF:			; Список адресов моделей цифр .
	.WORD	CIF0,CIF1,CIF2,CIF3,CIF4,CIF5,CIF6,CIF7,CIF8,CIF9

CIF0:			; Цифры .
WLU,GOR,WPU
WER,000,WER
WER,000,WER
WER,000,WER
NLU,GOR,NPU
CIF1:
LKO,WPU,000
000,WER,000
000,WER,000
000,WER,000
LKO,UKR,RKO
CIF2:
LKO,GOR,WPU
000,000,WER
WLU,GOR,NPU
WER,000,000
NLU,GOR,RKO
CIF3:
LKO,GOR,WPU
000,000,WER
000,LKO,LKR
000,000,WER
LKO,GOR,NPU
CIF4:
UKO,000,UKO
WER,000,WER
NLU,GOR,LKR
000,000,WER
000,000,DKO
CIF5:
WLU,GOR,RKO
WER,000,000
NLU,GOR,WPU
000,000,WER
LKO,GOR,NPU
CIF6:
WLU,GOR,RKO
WER,000,000
RKR,GOR,WPU
WER,000,WER
NLU,GOR,NPU
CIF7:
LKO,GOR,WPU
000,000,WER
000,000,WER
000,000,WER
000,000,DKO
CIF8:
WLU,GOR,WPU
WER,000,WER
RKR,GOR,LKR
WER,000,WER
NLU,GOR,NPU
CIF9:
WLU,GOR,WPU
WER,000,WER
NLU,GOR,LKR
000,000,WER
LKO,GOR,NPU
.END
