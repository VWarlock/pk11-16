


	RET	= RETURN
	id.buff	= 161120	;адреса регистров винта, далее смещения
	id.err	= 2		;  wr. precomp cyl.
	id.scnt = 4		;  Sector count rg.
	id.snum = 6		;  Sector number rg.
	id.cnlo = 10		;  Cylinder addr lo.
	id.cnhi = 12		;  Cylinder addr hi.
	id.sdh	= 14		;  Sector:Disk:Head
	id.csr	= 16		;  Command & status reg
	id.irq	= -4		;  interrupt, 4th bit of the head number
				;   and software reset
	DHCSR	= 177134
	DHBUF	= 177136
	FDBUF	= 177130
	DH.CSR	= DHCSR - 30000
	DH.BUF	= DHBUF - 30000
	DHVEC	= 240

	.includ	/p16/

	.asect
	.=0
	NOP
	BR	FDB
	.=42
	1000
	.=400
FDB:	MOV	#FDBOOT+3,R1	;номер устройства
	MOV	#FDBUF,R2	;регистр HD-FD PROC
	MOV	(R2),R0		;берем номер устройства cold-boot
	BIC	#^C7,R0		;сбрасываем остальные биты
	BIS	#10,R0		;для флопа
	MOVB	R0,(R1)+	;устанавливаем номер устройства
	CMP	-(R1),-(R1)	;R1 = FDBOOT
10$:	MOV	R1,(R2)		;загружаем процесс
	TSTB	(R2)		;проверяем готовность
	BPL	10$		;не готов
	TSTB	1(R2)		;проверяем на ошибку
	BNE	10$		;повторяем операцию
	BR	START		;запускаем процесс

FDBOOT:	1,0,1000,1000		;

	.=1000

START:	NEWROM	#RCMD		;создаем и стартуем процесс
	jmp	boot		;перегружаемся с винта
SPRC:	MOV	#RCMD,R0	;формируем блоки команд
	MOV	#CMDBL,R1	;для чтения-записи сектора целиком
	MOV	#4,R2		;- 4 блока
10$:	MOV	(R1)+,R3	;(на месте стартовой
	MOV	#100,R4		;нерезидентной части процесса -
20$:	MOV	R3,(R0)+	;метка RCMD, которая
	MOV	R3,(R0)+	;впоследствии затирается
	MOV	R3,(R0)+	;ввиду ненужности)
	MOV	R3,(R0)+
	SOB	R4,20$
	MOV	#207,(R0)+	;конец блока команд секторной операции
	SOB	R2,10$

INCMD:	CLR	R0
	CLR	R1
	WAITIN	#0
	TST	R0
	BMI	INCMD
	TST	R1
	BMI	INCMD
	MOV	DH.BUF,R2	; █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
	ROR	R2		; █  РАЗБОР ЗАПРОСА К ПРОЦЕССУ  █
	BCC	10$		; █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█
	SETINT	#DHVEC
10$:	ASL	R2
	MOV	#200,DH.BUF	;выставляем готовность
	MOV	#200,DH.CSR	;по дефолту
	CALL	RR		;подключаем адресное пр-во вызывавшего
	MOV	(R2),BLK	;разбираем элемент очереди ввода/вывода
	MOV	(R2)+,BLOCK	;начальный блок
	CLR	BLOCK+2		;старшее слово 32-битной ячейки
	MOVB	(R2)+,OPCOD	;код операции: 0 чтение, 373 объём устройства
	MOVB	(R2)+,R1	;код устройства DH0: DH1: etc
	MOV	(R2)+,ADDR	;начальный адрес
	MOV	(R2)+,ILEN	;длина в словах
	BIC	#^C7,R1		;кодов разделов всего восемь
	ASH	#3,R1		;преобразуем в смещение по табл. элементов
	ADD	#PARTBL,R1	;выбираем элемент таблицы разделов
	ADD	(R1)+,BLOCK	;прибавляем смещение по винту
	ADC	BLOCK+2		;к номеру блока
	ADD	(R1)+,BLOCK+2
	MOV	(R1)+,PLEN	;объём раздела
	MOVB	OPCOD,R1	;вспоминаем код операции
	BEQ	RWB		;нуль - чтение/запись
	CMPB	#373,R1		;373 - определение объема раздела
	BNE	INCMD		;что-то иное - игнорируем
	MOV	ADDR,R2		;возвращаем объем раздела по .spfun 373
	CALL	RR		;подключаем адресное пр-во вызывавшего прц.
	MOV	PLEN,(R2)	;кладем объем в буфер данных --//--
	BR	INCMD

RWB:	CALL	WAIT		; █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
				; █  ОБРАБОТКА ОПЕРАЦИЙ ЧТЕНИЯ-ЗАПИСИ  █
	MOV	MM,R0		; █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█
	BEQ	10$
	MOV	R0,ID.SCNT(R5)	;кол-во допустимых секторов
	MOV	#306,ID.CSR(R5)	;врубаем multiple mode если можно
	CALL	WAIT
10$:	CLR	RW
	MOV	ILEN,R4		;разбираемся - чтение или запись
	BEQ	90$	;игнорируем "пустую" операцию
	BPL	20$	;хотят читать - пусть RW остается нулём
	ADD	#2,RW	;флаг R/W - смещение по таблице кодов команд
	NEG	R4	;делаем положительное кол-во слов из отрицательного
20$:	MOV	R4,R1	;определяем выход за пределы раздела
	DEC	R1
	ASH	#-10,R1
	INC	R1
	ADD	BLK,R1	;номер блока, следующего за последним в операции
	CMP	PLEN,R1
	BLO	90$	;превышаем - операция не производится

	dval	#blk	;вывод на индикатор

	MOVB	R4,WLEN	;кол-во слов последнего сектора операции
	CLRB	R4
	SWAB	R4
	MOV	R4,R0	;кол-во целых секторов
	TST	WLEN
	BEQ	30$
	INC	R0
30$:	MOV	R0,ID.SCNT(R5)	;кол/во блоков округленное до большего
	MOV	BLOCK,R1
	MOV	BLOCK+2,R0
	DIV	SEC,R0
	INC	R1
	MOV	R1,ID.SNUM(R5)	;номер начального сектора операции
	MOV	R0,R1
	CLR	R0
	DIV	HEAD,R0
	BIC	#177740,R1
	BIS	#100,R1
	MOV	R1,ID.SDH(R5)	;номер поверхности
	MOV	R0,ID.CNLO(R5)	;мл байт номера цилиндра
	SWAB	R0
	MOV	R0,ID.CNHI(R5)	;ст байт номера цилиндра
	CLR	BNUM		;счетчик блоков для переключения страниц RAM
	MOV	RW,R1		;смещение по таблице команд чтение/запись
	MOV	RCOM(R1),ID.CSR(R5)	;даём команду читать-писать
	MOV	ADDR,R2		;начальный виртуальный адрес
	CALL	RR		;получаем физический
	TST	R4		;проверяем кол-во целых 8-кб кусков
	BEQ	80$		;нету ни одного
60$:	CALL	WAIT		;ждем готовности винта
	BCS	90$		;если ошибка завершаем операцию
	CALL	@RWCOM(R1)	;прогоняем сектор целиком
	INC	BNUM		;увеличиваем счетчик блоков
	BIT	#17,BNUM	;дошли до конца 8кб куска?
	BNE	70$		;нет
	MOV	@#UR2,@#UR1	;только для ПК11/16
	MOV	(R3)+,@#UR2	;проходим по адресному пространству
	SUB	#20000,R2	;вызвавшего процесса
70$:	SOB	R4,60$
80$:	TST	WLEN	;если число блоков было целым
	BEQ	90$	;завершаем операцию
	CALL	WAIT
	BCS	90$	;если ошибка
	MOV	#400,R4
	SUB	WLEN,R4
	ASL	R4	;получаем смещение от начала блока команд
	ADD	RWCOM(R1),R4
	CALL	(R4)	;прогоняем оставшуюся часть сектора
	CLR	R2
	MOV	WLEN,R4
	ASL	R4
	ADD	TCCOM(R1),R4
	CALL	(R4)	;обрабатываем остаток - для записи забиваем нулями
90$:	JMP	INCMD	;переходим на ожидание следующей команды процессу

WAIT:	MOV	ID.CSR(R5),R0	;считываем состояние винта
	BICB	#^C321,R0	;оставляем биты: BSY, DRDY, DSC, ERR
	BMI	WAIT		;если BSY=1, ждем дальше
	CMPB	#120,R0		;проверяем: DRDY=DSC=1, BSY=ERR=0
	CLC			;сбрасываем флаг ошибки
	BEQ	10$		;выходим по готовности без ошибки
	ROR	R0		;проверяем бит ERR
	BCC	WAIT		;ошибки нет - значит просто еще не готов
	MOVB	ID.ERR(R5),R0	;берем код ошибки
	MOVB	R0,DH.BUF+1	;кладем его в регистр
	MOVB	R0,DH.CSR+1	;и еще одна копия
10$:	RET			;выходим: флаг C - признак ошибки

RR:	MOV	@CALLER,R3	;разбираемся с адресным пространством
	ADD	#P.UR0,R3	;вызвавшего процесса
40$:	BIT	#160000,R2
	BEQ	50$
	TST	(R3)+
	SUB	#20000,R2
	BR	40$
50$:	ADD	#20000,R2
	MOV	(R3)+,@#UR1
	MOV	(R3)+,@#UR2
	RET

;STOP:	BIS	#1,2(SP)
;	RTI

BLOCK:	.BLKW	2	;32 битный номер блока по винту
ILEN:	HALT	;исходная длина в словах
ADDR:	HALT	;нач адрес
RW:	HALT	;флаг чтения-записи
MM:	HALT	;флаг Multiple Mode (IDE Block Mode)
RCOM:	41	;код команды чтения
WCOM:	61	;код команды записи
RWCOM:	RCMD,WCMD	;адреса процедур чтения и записи
TCCOM:	TCMD,CCMD	;адреса: фиктивное чтение и дозапись нулями

WLEN:	HALT	;положительная длина в словах
BNUM:	HALT	;номер блока по ходу операции
SEC:	HALT	;кол-во секторов на трек
HEAD:	HALT	;кол-во поверхностей
CALLER:	HALT	;указатель на указатель дескриптора вызвавшего процесса
BLK:	HALT	;номер начального блока операции
	.BYTE	140,12
PLEN:	HALT	;размер раздела
OPCOD:	HALT	;код операции из элемента очереди ввода-вывода
HDADDR:	ID.buff	;начальный адрес блока регистров винта
CMDBL:	MOV	(R5),(R2)+	;коды команд операций: чтение
	MOV	(R2)+,(R5)	;запись
	TST	(R5)		;фиктивное чтение для остатка слов
	MOV	R2,(R5)		;дозапись нулями конца последнего сектора
PARTBL:	1,0,12000,0		;таблица разделов
	12001,0,47037,0		; █▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀▀█
	65040,0,140240,0	; █ формат таблицы разделов  █
	61040,0,4000,0		; █ 1 и 2 слово - 32-битный  █
	25300,1,177777,0	; █ номер начального блока   █
	25300,2,177777,0	; █ 3 слово - длина в блоках █
	55300,3,133000,0	; █ 4 слово - резерв         █
	10300,4,177777,0	; █▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄▄█

RCMD:	MOV	#1000,SP
	JSR	R5,MV		;копируем карту памяти HALT в USER
	UR4,HR4,3
	TST	@#DHBUF-20000	;проверяем: процесс уже запущен?
	BEQ	10$		;нет
	SETPRI	#1
	MOV	RUNNING,R1	;запущен - самоуничтожаемся
	SUB	#P.SP,R1
	MOV	R1,@#174054	;suicide
	NOP
10$:	GET4K	#1		;захватываем 4кб RAM для себя
	MOV	R0,@#UR1	;подключаем её
	JSR	R5,MV		;копируем из RT в захваченную память
	20000,0,4000
	MOV	R0,@#UR0	;перебрасываем туда управление
	MOV	RUNNING,R1
	BIC	#20000,P.MASK-P.SP(R1)	;запрет прерывания пультом
	ADD	#P.CPRC-P.SP,R1
	MOV	R1,CALLER	;@адрес дескриптора вызывающего процесса
	ADD	#P.NAME-P.CPRC,R1
	JSR	R5,MV2		;копируем имя процесса в дескриптор
	PRCNAM,10
	PROREG	#TCSR		;захватываем регистр состояния
	PROREG	#TBUF		;захватываем регистр команд
	MOV	HDADDR,R5	;R5 - указатель на блок регистров
	MOV	#16,ID.IRQ(R5)	;Resetим винт
	MOV	#12,ID.IRQ(R5)
	CALL	WAIT
	MOV	#354,ID.CSR(R5)	;даем команду прочитать паспорт винта
	CALL	WAIT
	TST	(R5)		;пропускаем ненужное
	TST	(R5)
	TST	(R5)
	MOV	(R5),HEAD	;количество поверхностей
	TST	(R5)
	TST	(R5)
	MOV	(R5),SEC	;секторов на трек
	MOV	#40.,R0
	TST	(R5)
	SOB	R0,.-2
	MOV	#MM,R0
	MOV	(R5),(R0)	;кол-во секторов IDE block mode
	bic	#177400,(R0)+	;иногда установлен 15 бит
	BEQ	20$
	MOV	#304,(R0)+	;команды R/W multiple mode
	MOV	#305,(R0)+
	BR	30$
20$:	MOV	#41,(R0)+	;команды просто R/W
	MOV	#61,(R0)+
30$:	MOV	#256.-9.,R0
	TST	(R5)
	SOB	R0,.-2
	SETPRI	#27
	JMP	SPRC		;передаем управление резидентной части

MV:	MOV	(R5)+,R1	;процедура
MV2:	MOV	(R5)+,R2	;пересылки
	MOV	(R5)+,R3	;массива
10$:	MOV	(R2)+,(R1)+
	SOB	R3,10$
	RTS	R5

BOOT:	RESET	;загрузчик системы с винта
	MOV	#CMBOOT,@#DHBUF
	CLR	PC

CMBOOT:	0,0,0,400

PRCNAM:	.ASCII	/iDEAtA iNtERFACE/	;имя процесса
TCSR:	.WORD	DHCSR, 177677, 200, 2000, 100000, 177777	;дескрипторы
TBUF:	.WORD	DHBUF, 0, 0, 2000, 0, 177777	;регистров процесса

WCMD 	= RCMD + 1002		;буфера под массивы команд
TCMD 	= WCMD + 1002
CCMD 	= TCMD + 1002

	.END	START		;сам догадайся что это такое

                                                                                                                                                                                               